{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Portafolio","text":""},{"location":"#sobre-mi","title":"Sobre m\u00ed","text":""},{"location":"#hola-soy-salamanca-esquivel-eduardo","title":"Hola, soy Salamanca Esquivel Eduardo","text":"<p>Soy Estudiante de Ingenier\u00eda Mecatr\u00f3nica en IBERO Puebla. Me interesan el deporte, la mec\u00e1nica y la tecnolog\u00eda.  </p>"},{"location":"#contacto","title":"Contacto","text":"<ul> <li>\ud83d\udce7 Correo institucional: 203279@iberopuebla.mx </li> </ul>"},{"location":"#de-lo-que-me-siento-orgulloso","title":"De lo que me siento orgulloso","text":""},{"location":"#proyecto-o-logro","title":"[proyecto o logro]","text":"<p>Calculadora binaria con arduino UNO.  </p> <p>Maquina de estados de puente elevadizo</p> <p>Robot de balance mediante detecci\u00f3n con c\u00e1mara</p>"},{"location":"Coche%20fut/","title":"Coche Omnidireccional Controlado por Bluetooth (ESP32 + Xbox Controller)","text":"<p>Proyecto acad\u00e9mico de control de movimiento y actuadores, integrando el ESP32 con comunicaci\u00f3n Bluetooth y llantas omnidireccionales. Enlace directo</p>"},{"location":"Coche%20fut/#1-resumen","title":"1\ufe0f Resumen","text":"<ul> <li>Nombre del proyecto: Coche de Futbol Bluetooth con ESP32  </li> <li>Equipo / Autor(es): Eduardo Salamanca y equipo  </li> <li>Curso / Asignatura: Electr\u00f3nica y Programaci\u00f3n de Microcontroladores  </li> <li>Fecha: 20/10/2025  </li> <li>Descripci\u00f3n breve:   Este proyecto implementa un coche omnidireccional controlado mediante Bluetooth, usando un control de Xbox y un ESP32.   El objetivo final fue participar en partidos tipo f\u00fatbol con los coches controlados remotamente.</li> </ul>"},{"location":"Coche%20fut/#2-objetivos","title":"2\ufe0f Objetivos","text":"<ul> <li> <p>General:   Dise\u00f1ar e implementar un sistema m\u00f3vil controlado por Bluetooth que permita controlar la direcci\u00f3n, velocidad y rotaci\u00f3n mediante un control inal\u00e1mbrico.</p> </li> <li> <p>Espec\u00edficos: </p> </li> <li>Implementar el control de movimiento con llantas omnidireccionales.  </li> <li>Integrar puentes H para controlar los motores.  </li> <li>Programar el ESP32 para recibir se\u00f1ales Bluetooth del control.  </li> <li>Dise\u00f1ar la carcasa del coche en MDF mediante corte l\u00e1ser.  </li> <li>Incorporar el control de servomotores y LED del proyecto anterior.  </li> </ul>"},{"location":"Coche%20fut/#3-alcance-y-exclusiones","title":"3\ufe0f Alcance y Exclusiones","text":"<ul> <li>Incluye: </li> <li>Control inal\u00e1mbrico con Bluetooth.  </li> <li>Control direccional completo (adelante, atr\u00e1s, izquierda, derecha, giro).  </li> <li>Control de velocidad variable.  </li> <li>Estructura mec\u00e1nica cortada en MDF.  </li> <li> <p>Integraci\u00f3n de LEDs y servomotores del proyecto anterior.  </p> </li> <li> <p>No incluye: </p> </li> <li>Control por Wi-Fi o conexi\u00f3n a Internet.  </li> <li>Sensores de distancia o evitaci\u00f3n de obst\u00e1culos (versi\u00f3n futura).  </li> </ul>"},{"location":"Coche%20fut/#4-requisitos","title":"4\ufe0f Requisitos","text":""},{"location":"Coche%20fut/#software","title":"Software","text":"<ul> <li>IDE: Arduino IDE (versi\u00f3n m\u00e1s reciente)  </li> <li>Plataforma: ESP32 Dev Module  </li> <li>Librer\u00edas necesarias: </li> <li><code>BluetoothSerial.h</code> </li> <li><code>Servo.h</code> </li> </ul>"},{"location":"Coche%20fut/#hardware","title":"Hardware","text":"<ul> <li>ESP32  </li> <li>4 llantas omnidireccionales  </li> <li>2 puentes H L298N  </li> <li>Servomotor SG90 (para direcci\u00f3n o accesorio)  </li> <li>Jumpers y cables Dupont  </li> <li>Fuente de alimentaci\u00f3n 12 V  </li> <li>Carcasa de MDF cortada con l\u00e1ser  </li> <li>Control Xbox (Bluetooth)  </li> <li>Protoboard  </li> </ul>"},{"location":"Coche%20fut/#5-codigo-principal-esp32","title":"5\ufe0f C\u00f3digo Principal (ESP32)","text":"<p>```cpp include \"BluetoothSerial.h\" include  <p>BluetoothSerial SerialBT;</p> <p>define ENA 25 define IN1 26 define IN2 27 define IN3 14 define IN4 12 define ENB 13</p> <p>Servo servo;</p> <p>char comando;</p> <p>void setup() {   Serial.begin(115200);   SerialBT.begin(\"Coche_BT_ESP32\");   servo.attach(15);</p> <p>pinMode(ENA, OUTPUT);   pinMode(ENB, OUTPUT);   pinMode(IN1, OUTPUT);   pinMode(IN2, OUTPUT);   pinMode(IN3, OUTPUT);   pinMode(IN4, OUTPUT);</p> <p>Serial.println(\"Esperando conexi\u00f3n Bluetooth...\"); }</p> <p>void loop() {   if (SerialBT.available()) {     comando = SerialBT.read();     Serial.print(\"Comando recibido: \");     Serial.println(comando);</p> <pre><code>switch (comando) {\n  case 'F':  // Adelante\n    digitalWrite(IN1, HIGH);\n    digitalWrite(IN2, LOW);\n    digitalWrite(IN3, HIGH);\n    digitalWrite(IN4, LOW);\n    analogWrite(ENA, 255);\n    analogWrite(ENB, 255);\n    break;\n\n  case 'B':  // Atr\u00e1s\n    digitalWrite(IN1, LOW);\n    digitalWrite(IN2, HIGH);\n    digitalWrite(IN3, LOW);\n    digitalWrite(IN4, HIGH);\n    analogWrite(ENA, 255);\n    analogWrite(ENB, 255);\n    break;\n\n  case 'L':  // Izquierda\n    digitalWrite(IN1, LOW);\n    digitalWrite(IN2, HIGH);\n    digitalWrite(IN3, HIGH);\n    digitalWrite(IN4, LOW);\n    break;\n\n  case 'R':  // Derecha\n    digitalWrite(IN1, HIGH);\n    digitalWrite(IN2, LOW);\n    digitalWrite(IN3, LOW);\n    digitalWrite(IN4, HIGH);\n    break;\n\n  case 'S':  // Stop\n    digitalWrite(IN1, LOW);\n    digitalWrite(IN2, LOW);\n    digitalWrite(IN3, LOW);\n    digitalWrite(IN4, LOW);\n    break;\n\n  case 'V':  // Servo: variaci\u00f3n de \u00e1ngulo\n    for (int i = 0; i &lt;= 180; i += 10) {\n      servo.write(i);\n      delay(50);\n    }\n    for (int i = 180; i &gt;= 0; i -= 10) {\n      servo.write(i);\n      delay(50);\n    }\n    break;\n}\n</code></pre> <p>} }</p>"},{"location":"Robot%20Balancin/","title":"Robot con Visi\u00f3n por Computadora y Control PID","text":""},{"location":"Robot%20Balancin/#descripcion-general","title":"Descripci\u00f3n General","text":"<p>Este proyecto consiste en un robot balanceador con plataforma m\u00f3vil, controlado mediante visi\u00f3n por computadora (OpenCV) y estabilizado con dos servomotores MG996R. El sistema detecta una pelota azul sobre una plataforma negra y ajusta la inclinaci\u00f3n mediante un control PID en tiempo real.</p> <p>El robot fue construido utilizando:</p> <ul> <li>2 servomotores MG996R de 15 kg</li> <li>Estructura y articulaciones impresas en 3D</li> <li>Plataforma de MDF</li> <li>ESP32 con comunicaci\u00f3n por Bluetooth</li> <li>Python + OpenCV para visi\u00f3n por computadora</li> </ul>"},{"location":"Robot%20Balancin/#autores","title":"Autores","text":"<ul> <li>Eduardo Salamanca</li> <li>Juan Carlos P\u00e9rez</li> <li>Andr\u00e9 S\u00e1nchez</li> <li>Sebasti\u00e1n S\u00e1nchez</li> </ul>"},{"location":"Robot%20Balancin/#caracteristicas-principales","title":"Caracter\u00edsticas Principales","text":"<ul> <li>Detecci\u00f3n de plataforma negra mediante segmentaci\u00f3n HSV.</li> <li>Detecci\u00f3n de pelota azul y c\u00e1lculo preciso del centro.</li> <li>Control PID ajustable en tiempo real mediante sliders en OpenCV.</li> <li>Comunicaci\u00f3n serial Bluetooth con ESP32.</li> <li>Movimientos suaves gracias a filtros y suavizado.</li> </ul>"},{"location":"Robot%20Balancin/#enlace-al-video-de-funcionamiento","title":"Enlace al Video de Funcionamiento","text":"<p>Video demostrativo del robot</p> <p>Demostraci\u00f3n del sistema detectando la pelota, calculando la posici\u00f3n y moviendo los servomotores en tiempo real.</p>"},{"location":"Robot%20Balancin/#hardware-utilizado","title":"Hardware Utilizado","text":"Componente Cant. Nota Servomotor MG996R 2 15 kg torque ESP32 1 Control y comunicaci\u00f3n Plataforma MDF 1 Soporte f\u00edsico Piezas impresas en 3D 4+ Articulaciones y brazos"},{"location":"Robot%20Balancin/#software-utilizado","title":"Software Utilizado","text":"<ul> <li>Python 3.10+</li> <li>OpenCV</li> <li>NumPy</li> <li>PySerial</li> <li>Arduino IDE</li> </ul>"},{"location":"Robot%20Balancin/#funcionamiento","title":"Funcionamiento","text":""},{"location":"Robot%20Balancin/#1-deteccion-de-plataforma","title":"1. Detecci\u00f3n de Plataforma","text":"<p>Se segmenta el \u00e1rea negra mediante un threshold en HSV:</p> <pre><code>lower_black = np.array([0, 0, 0])\nupper_black = np.array([180, 255, THRESHOLD_PLATAFORMA])\n</code></pre> <p>Se obtiene el contorno m\u00e1s grande y su centro.</p>"},{"location":"Robot%20Balancin/#2-deteccion-de-pelota-azul","title":"2. Detecci\u00f3n de Pelota Azul","text":"<pre><code>LOW_BLUE = np.array([100, 150, 70])\nHIGH_BLUE = np.array([130, 255, 255])\n</code></pre> <p>Se calcula centro y radio para validar detecci\u00f3n.</p>"},{"location":"Robot%20Balancin/#3-calculo-de-error","title":"3. C\u00e1lculo de Error","text":"<pre><code>error_x = centro_pelota.x - centro_plataforma.x\nerror_y = centro_pelota.y - centro_plataforma.y\n</code></pre>"},{"location":"Robot%20Balancin/#4-control-pid","title":"4. Control PID","text":"<pre><code>output_x = Kp*error_x + Ki*integral_x + Kd*derivative_x\n</code></pre> <p>Sliders en OpenCV permiten ajustar Kp, Ki y Kd.</p>"},{"location":"Robot%20Balancin/#5-envio-al-esp32","title":"5. Env\u00edo al ESP32","text":"<pre><code>mensaje = f\"{int(current_x)},{int(current_y)}\\n\"\nesp32.write(mensaje.encode())\n</code></pre>"},{"location":"Robot%20Balancin/#mecanica","title":"Mec\u00e1nica","text":""},{"location":"Robot%20Balancin/#codigo-p","title":"C\u00f3digo P","text":"<p>Python (Visi\u00f3n por Computadora)</p> <pre><code>import cv2\nimport time\nimport numpy as np\nimport serial\nimport serial.tools.list_ports\n\n# ------------------- Configuraci\u00f3n Serial Bluetooth -------------------\nesp32_port = 'COM3'\nbaud_rate = 115200\n\nprint(\"=\" * 50)\nprint(\"Intentando conectar con ESP32...\")\nprint(f\"Puerto: {esp32_port} | Baudios: {baud_rate}\")\n\ndef listar_puertos():\n    puertos = serial.tools.list_ports.comports()\n    print(\"\\n Puertos COM disponibles:\")\n    if len(puertos) == 0:\n        print(\"  No se encontraron puertos COM\")\n    for puerto in puertos:\n        print(f\"   \u2022 {puerto.device}: {puerto.description}\")\n    print()\n\nlistar_puertos()\n\ntry:\n    esp32 = serial.Serial(esp32_port, baud_rate, timeout=1)\n    time.sleep(2)\n    print(f\" \u00a1Conectado al ESP32 en {esp32_port}!\")\nexcept serial.SerialException as e:\n    print(f\" Error de conexi\u00f3n serial: {e}\")\n    print(\"\\n Posibles soluciones:\")\n    print(\"   1. Verifica que el puerto COM sea correcto\")\n    print(\"   2. Cierra el IDE de Arduino si est\u00e1 abierto\")\n    print(\"   3. Cierra cualquier monitor serial activo\")\n    print(\"   4. Desconecta y reconecta el ESP32\")\n    print(\"   5. Verifica que el ESP32 est\u00e9 encendido\")\n    esp32 = None\nexcept Exception as e:\n    print(f\" Error inesperado: {e}\")\n    esp32 = None\n\nprint(\"=\" * 50)\n\n# ------------------- Configuraci\u00f3n c\u00e1mara -------------------\ncap = cv2.VideoCapture(1)\ncap.set(cv2.CAP_PROP_FRAME_WIDTH, 640)\ncap.set(cv2.CAP_PROP_FRAME_HEIGHT, 480)\n\nif not cap.isOpened():\n    print(\"Error: No se pudo abrir la c\u00e1mara\")\n    exit()\n\n# ------------------- Posici\u00f3n inicial servos -------------------\ncenter_angle = 50\ncurrent_x = center_angle\ncurrent_y = center_angle\nDEAD_ZONE = 15  # Zona muerta reducida\nsmoothing = 0.3  # Suavizado reducido para respuesta m\u00e1s r\u00e1pida\n\n# ------------------- Par\u00e1metros PID ajustables -------------------\nKp = 0.15\nKi = 0.001\nKd = 0.20\n\nprev_error_x = 0\nprev_error_y = 0\nintegral_x = 0\nintegral_y = 0\n\nMAX_INTEGRAL = 50\n\n# ------------------- Par\u00e1metros de detecci\u00f3n -------------------\n# Threshold para plataforma NEGRA (0-255, valor V en HSV)\nTHRESHOLD_PLATAFORMA = 120  # Ampliado para detectar m\u00e1s tonos\nAREA_MIN_PLATAFORMA = 1000  # \u00c1rea m\u00ednima del cuadrado\n\n# Rango HSV para pelota azul\nLOW_BLUE = np.array([100, 150, 70])\nHIGH_BLUE = np.array([130, 255, 255])\nAREA_MIN_PELOTA = 200\nRADIO_MIN_PELOTA = 8\n\n# ------------------- Funci\u00f3n para limitar valores -------------------\ndef constrain(value, min_val, max_val):\n    return max(min_val, min(max_val, value))\n\n# ------------------- Callbacks para sliders -------------------\ndef update_kp(val):\n    global Kp\n    Kp = val / 100.0  # Slider 0-100, valor real 0.00-1.00\n    print(f\"Kp = {Kp:.3f}\")\n\ndef update_ki(val):\n    global Ki\n    Ki = val / 1000.0  # Slider 0-100, valor real 0.000-0.100\n    print(f\"Ki = {Ki:.4f}\")\n\ndef update_kd(val):\n    global Kd\n    Kd = val / 100.0  # Slider 0-100, valor real 0.00-1.00\n    print(f\"Kd = {Kd:.3f}\")\n\n# ------------------- Crear ventana de control -------------------\ncv2.namedWindow('Control PID')\ncv2.createTrackbar('Kp x100', 'Control PID', int(Kp * 100), 100, update_kp)\ncv2.createTrackbar('Ki x1000', 'Control PID', int(Ki * 1000), 100, update_ki)\ncv2.createTrackbar('Kd x100', 'Control PID', int(Kd * 100), 100, update_kd)\n\nprev_time = time.time()\nprint(\"=\" * 50)\nprint(\"Sistema de Balance: Plataforma + Pelota\")\nprint(\"=\" * 50)\nprint(\"CONFIGURACI\u00d3N:\")\nprint(f\"  \u2022 Centro servos: {center_angle}\u00b0 (Rango: 0-180\u00b0)\")\nprint(f\"  \u2022 Zona muerta: \u00b1{DEAD_ZONE} p\u00edxeles\")\nprint(f\"  \u2022 Suavizado: {smoothing}\")\nprint(f\"  \u2022 Threshold plataforma: {THRESHOLD_PLATAFORMA}\")\nprint(f\"  \u2022 PID: Kp={Kp} Ki={Ki} Kd={Kd}\")\nprint(\"\\nDETECCI\u00d3N:\")\nprint(\"  \u2022 PLATAFORMA NEGRA (HSV): Detecta \u00e1rea m\u00e1s grande de tonos oscuros\")\nprint(\"  \u2022 PELOTA AZUL: Posici\u00f3n para calcular error\")\nprint(\"  \u2022 Usa teclas '1'/'2' para ajustar threshold\")\nprint(\"\\nCONTROLES:\")\nprint(\"  \u2022 'q' \u2192 Salir\")\nprint(\"  \u2022 'c' \u2192 Resetear integrales\")\nprint(\"  \u2022 '1' \u2192 Threshold -5\")\nprint(\"  \u2022 '2' \u2192 Threshold +5\")\nprint(\"  \u2022 Sliders \u2192 Ajustar PID en tiempo real\")\nprint(\"=\" * 50)\n\nframe_count = 0\nfps_time = time.time()\nfps = 0\n\nwhile True:\n    ret, frame = cap.read()\n    if not ret:\n        print(\"Error: No se pudo leer frame de la c\u00e1mara\")\n        break\n\n    frame = cv2.flip(frame, 1)\n    height, width = frame.shape[:2]\n    centrox, centroy = width//2, height//2\n\n    # ===============================================================\n    # DETECCI\u00d3N 1: PLATAFORMA NEGRA (HSV) - \u00c1REA M\u00c1S GRANDE\n    # ===============================================================\n    hsv_plat = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)\n\n    lower_black = np.array([0, 0, 0])\n    upper_black = np.array([180, 255, THRESHOLD_PLATAFORMA])\n\n    mask_plataforma = cv2.inRange(hsv_plat, lower_black, upper_black)\n\n    kernel_plat = np.ones((7,7), np.uint8)\n    mask_plataforma = cv2.morphologyEx(mask_plataforma, cv2.MORPH_CLOSE, kernel_plat)\n    mask_plataforma = cv2.morphologyEx(mask_plataforma, cv2.MORPH_OPEN, kernel_plat)\n    mask_plataforma = cv2.dilate(mask_plataforma, kernel_plat, iterations=1)\n\n    contours_plat, _ = cv2.findContours(mask_plataforma, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n    area_max_plat = 0\n    contorno_plat = None\n    centro_plataforma = None\n    rectangulo_info = None\n\n    for c in contours_plat:\n        area = cv2.contourArea(c)\n        if area &gt; area_max_plat and area &gt; AREA_MIN_PLATAFORMA:\n            area_max_plat = area\n            contorno_plat = c\n            rectangulo_info = cv2.minAreaRect(c)\n\n            M = cv2.moments(c)\n            if M[\"m00\"] != 0:\n                cx_plat = int(M[\"m10\"] / M[\"m00\"])\n                cy_plat = int(M[\"m01\"] / M[\"m00\"])\n                centro_plataforma = (cx_plat, cy_plat)\n\n    # ===============================================================\n    # DETECCI\u00d3N 2: PELOTA AZUL\n    # ===============================================================\n    hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)\n    mask_pelota = cv2.inRange(hsv, LOW_BLUE, HIGH_BLUE)\n\n    kernel_pelota = np.ones((5,5), np.uint8)\n    mask_pelota = cv2.morphologyEx(mask_pelota, cv2.MORPH_OPEN, kernel_pelota)\n    mask_pelota = cv2.morphologyEx(mask_pelota, cv2.MORPH_CLOSE, kernel_pelota)\n    mask_pelota = cv2.dilate(mask_pelota, kernel_pelota, iterations=1)\n\n    contours_pelota, _ = cv2.findContours(mask_pelota, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n    area_max_pelota = 0\n    contorno_pelota = None\n    centro_pelota = None\n    radio_pelota = 0\n\n    for c in contours_pelota:\n        area = cv2.contourArea(c)\n        if area &gt; area_max_pelota:\n            area_max_pelota = area\n            contorno_pelota = c\n            (x_pel, y_pel), radio_pelota = cv2.minEnclosingCircle(c)\n            if radio_pelota &gt; RADIO_MIN_PELOTA and area &gt; AREA_MIN_PELOTA:\n                centro_pelota = (int(x_pel), int(y_pel))\n\n    # ===============================================================\n    # VISUALIZACI\u00d3N\n    # ===============================================================\n    out_original = frame.copy()\n\n    mask_combinada = cv2.bitwise_or(mask_plataforma, mask_pelota)\n    out_deteccion = cv2.cvtColor(mask_combinada, cv2.COLOR_GRAY2BGR)\n\n    out_deteccion[mask_plataforma &gt; 0] = [255, 0, 0]\n    out_deteccion[mask_pelota &gt; 0] = [0, 255, 255]\n\n    # ===============================================================\n    # CALCULAR TIEMPO\n    # ===============================================================\n    current_time = time.time()\n    dt = current_time - prev_time\n    prev_time = current_time\n    if dt &lt; 0.001:\n        dt = 0.001\n\n    # ===============================================================\n    # CONTROL PID - SOLO CAMBIO: ERROR X\n    # ===============================================================\n    plataforma_detectada = (contorno_plat is not None and area_max_plat &gt; AREA_MIN_PLATAFORMA and centro_plataforma is not None)\n    pelota_detectada = (contorno_pelota is not None and centro_pelota is not None)\n\n    if plataforma_detectada:\n        if rectangulo_info:\n            box = cv2.boxPoints(rectangulo_info)\n            box = np.intp(box)\n            cv2.drawContours(out_original, [box], 0, (0, 255, 0), 3)\n            cv2.drawContours(out_deteccion, [box], 0, (0, 255, 0), 2)\n\n        cv2.circle(out_original, centro_plataforma, 12, (0, 255, 0), 3)\n        cv2.circle(out_original, centro_plataforma, 5, (0, 255, 0), -1)\n        cv2.putText(out_original, \"PLATAFORMA\", (centro_plataforma[0]-40, centro_plataforma[1]-20),\n                   cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 255, 0), 2)\n\n        if pelota_detectada:\n            cv2.circle(out_original, centro_pelota, int(radio_pelota), (0, 255, 255), 2)\n            cv2.circle(out_original, centro_pelota, 5, (255, 0, 0), -1)\n            cv2.putText(out_original, \"PELOTA\", (centro_pelota[0]-30, centro_pelota[1]+25),\n                       cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 255, 0), 2)\n            QQQ\n            cv2.line(out_original, centro_plataforma, centro_pelota, (255, 0, 255), 2)\n            cv2.line(out_deteccion, centro_plataforma, centro_pelota, (255, 255, 255), 2)\n\n            # ===============================================================\n            # CALCULAR ERROR: Pelota respecto al centro de la plataforma\n            # SOLO CAMBIO: X sin signo negativo\n            # ===============================================================\n            error_x = (centro_pelota[0] - centro_plataforma[0])  # CORREGIDO X\n            error_y = (centro_pelota[1] - centro_plataforma[1])  # Y sigue invertido\n\n            if abs(error_x) &lt; DEAD_ZONE: \n                error_x = 0\n            if abs(error_y) &lt; DEAD_ZONE: \n                error_y = 0\n\n            integral_x += error_x * dt\n            integral_y += error_y * dt\n            integral_x = constrain(integral_x, -MAX_INTEGRAL, MAX_INTEGRAL)\n            integral_y = constrain(integral_y, -MAX_INTEGRAL, MAX_INTEGRAL)\n\n            derivative_x = (error_x - prev_error_x) / dt\n            derivative_y = (error_y - prev_error_y) / dt\n\n            output_x = Kp*error_x + Ki*integral_x + Kd*derivative_x\n            output_y = Kp*error_y + Ki*integral_y + Kd*derivative_y\n\n            prev_error_x = error_x\n            prev_error_y = error_y\n\n            delta_x = output_x * 0.15\n            delta_y = output_y * 0.15\n\n            target_x = center_angle + delta_x\n            target_y = center_angle + delta_y\n\n            current_x = current_x * (1 - smoothing) + target_x * smoothing\n            current_y = current_y * (1 - smoothing) + target_y * smoothing\n\n            current_x = constrain(current_x, 0, 110)\n            current_y = constrain(current_y, 0, 110)\n\n            if esp32:\n                mensaje = f\"{int(current_x)},{int(current_y)}\\n\"\n                try:\n                    esp32.write(mensaje.encode())\n                    if esp32.in_waiting &gt; 0:\n                        respuesta = esp32.readline().decode('utf-8', errors='ignore').strip()\n                        if respuesta and frame_count % 30 == 0:\n                            print(f\"\ud83d\udce1 ESP32: {respuesta}\")\n                except Exception as e:\n                    if frame_count % 30 == 0:\n                        print(f\"\u2717 Error: {e}\")\n\n            if frame_count % 5 == 0:\n                print(f\"\u2713 X={int(current_x):3d}\u00b0 Y={int(current_y):3d}\u00b0 | Err X={-error_x:4d} Y={-error_y:4d} | Out X={output_x:6.1f} Y={output_y:6.1f}\")\n\n            cv2.putText(out_original, f\"Error X:{-error_x} Y:{-error_y}\", (10,30),\n                        cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255,255,0), 2)\n            cv2.putText(out_original, f\"Servo X:{int(current_x)} Y:{int(current_y)}\", (10,60),\n                        cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255,255,0), 2)\n            cv2.putText(out_original, f\"Distancia: {int(np.sqrt(error_x**2 + error_y**2))} px\", (10,90),\n                        cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0,255,255), 2)\n        else:\n            cv2.putText(out_original, \"PELOTA NO DETECTADA\", (10,30),\n                        cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0,165,255), 2)\n\n            integral_x = 0\n            integral_y = 0\n            prev_error_x = 0\n            prev_error_y = 0\n\n            current_x = current_x * (1 - smoothing*0.5) + center_angle * smoothing * 0.5\n            current_y = current_y * (1 - smoothing*0.5) + center_angle * smoothing * 0.5\n\n            if esp32 and frame_count % 10 == 0:\n                try:\n                    esp32.write(f\"{int(current_x)},{int(current_y)}\\n\".encode())\n                except:\n                    pass\n\n            if frame_count % 30 == 0:\n                print(f\"\u26a0 Solo plataforma. Centrando: X={int(current_x)}\u00b0 Y={int(current_y)}\u00b0\")\n    else:\n        cv2.putText(out_original, \"PLATAFORMA NO DETECTADA\", (10,30),\n                    cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0,0,255), 2)\n\n        integral_x = 0\n        integral_y = 0\n        prev_error_x = 0\n        prev_error_y = 0\n\n        current_x = current_x * (1 - smoothing*0.5) + center_angle * smoothing * 0.5\n        current_y = current_y * (1 - smoothing*0.5) + center_angle * smoothing * 0.5\n\n        if esp32 and frame_count % 10 == 0:\n            try:\n                esp32.write(f\"{int(current_x)},{int(current_y)}\\n\".encode())\n            except:\n                pass\n\n        if frame_count % 30 == 0:\n            print(f\"\u26a0 Sin detecci\u00f3n. Centrando: X={int(current_x)}\u00b0 Y={int(current_y)}\u00b0\")\n\n    cv2.circle(out_original, (centrox, centroy), DEAD_ZONE, (128,128,128), 1)\n    cv2.line(out_original, (centrox-15, centroy), (centrox+15, centroy), (128,128,128), 1)\n    cv2.line(out_original, (centrox, centroy-15), (centrox, centroy+15), (128,128,128), 1)\n\n    cv2.putText(out_original, f\"Plat:{int(area_max_plat)} Pel:{int(area_max_pelota)}\", (10,height-40),\n                cv2.FONT_HERSHEY_SIMPLEX, 0.5, (200,200,200), 1)\n    cv2.putText(out_original, f\"Threshold:{THRESHOLD_PLATAFORMA} (1/2)\", (10,height-15),\n                cv2.FONT_HERSHEY_SIMPLEX, 0.5, (200,200,200), 1)\n\n    cv2.putText(out_original, f\"PID: Kp={Kp:.2f} Ki={Ki:.3f} Kd={Kd:.2f}\", (10,120),\n                cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255,200,0), 2)\n\n    frame_count += 1\n    if time.time() - fps_time &gt; 1.0:\n        fps = frame_count\n        frame_count = 0\n        fps_time = time.time()\n\n    cv2.putText(out_original, f\"FPS: {fps}\", (width-100, 30),\n                cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0,255,0), 2)\n\n    cv2.imshow(\"Sistema de Balance - Original\", out_original)\n    cv2.imshow(\"Deteccion: Plataforma(Azul) + Pelota(Amarillo)\", out_deteccion)\n\n    key = cv2.waitKey(1) &amp; 0xFF\n    if key == ord('q'):\n        break\n    elif key == ord('c'):\n        integral_x = 0\n        integral_y = 0\n        print(\"Integrales reseteadas\")\n    elif key == ord('1'):\n        THRESHOLD_PLATAFORMA = max(10, THRESHOLD_PLATAFORMA - 5)\n        print(f\"Threshold: {THRESHOLD_PLATAFORMA}\")\n    elif key == ord('2'):\n        THRESHOLD_PLATAFORMA = min(250, THRESHOLD_PLATAFORMA + 5)\n        print(f\"Threshold: {THRESHOLD_PLATAFORMA}\")\n\nprint(\"\\nCerrando sistema...\")\ncap.release()\nif esp32:\n    esp32.write(f\"{center_angle},{center_angle}\\n\".encode())\n    time.sleep(0.1)\n    esp32.close()\n    print(\"Conexi\u00f3n serial cerrada\")\ncv2.destroyAllWindows()\nprint(\"Sistema finalizado\")\n\n---\n\n## C\u00f3digo ESP32 / Arduino\n\n```cpp\n#include &lt;ESP32Servo.h&gt;\n\n// =============== CONFIGURACI\u00d3N DE PINES ===============\nconst int PIN_SERVO_X = 18;  // Servo que controla eje X (horizontal)\nconst int PIN_SERVO_Y = 19;  // Servo que controla eje Y (vertical)\n\n// =============== CONFIGURACI\u00d3N DE SERVOS ===============\nServo servoX;\nServo servoY;\n\n// Par\u00e1metros PWM para servos (ajustar seg\u00fan tu modelo)\nconst int PWM_MIN = 500;   // Ancho de pulso m\u00ednimo en microsegundos\nconst int PWM_MAX = 2400;  // Ancho de pulso m\u00e1ximo en microsegundos\n\n// =============== POSICI\u00d3N INICIAL ===============\nconst int CENTRO = 35;     // Posici\u00f3n central (0-180 grados)\n\n// =============== VARIABLES DE COMUNICACI\u00d3N ===============\nString inputString = \"\";         // Buffer para datos recibidos\nbool stringComplete = false;     // Bandera de comando completo\n\n// =============== VARIABLES DE CONTROL ===============\nint posicionX = CENTRO;\nint posicionY = CENTRO;\nunsigned long ultimoComando = 0;\nconst unsigned long TIMEOUT = 2000;  // Timeout en ms (volver al centro si no hay datos)\n\n// =============== CONFIGURACI\u00d3N INICIAL ===============\nvoid setup() {\n  // Iniciar comunicaci\u00f3n serial\n  Serial.begin(115200);\n\n  // Reservar memoria para el buffer\n  inputString.reserve(20);\n\n  // Configurar servos con par\u00e1metros PWM personalizados\n  servoX.attach(PIN_SERVO_X, PWM_MIN, PWM_MAX);\n  servoY.attach(PIN_SERVO_Y, PWM_MIN, PWM_MAX);\n\n  // Mover a posici\u00f3n inicial centrada\n  servoX.write(CENTRO);\n  servoY.write(CENTRO);\n\n  // Esperar estabilizaci\u00f3n\n  delay(500);\n\n  // Mensaje de inicio\n  Serial.println(\"========================================\");\n  Serial.println(\"ESP32 - Sistema de Balance de Pelota\");\n  Serial.println(\"========================================\");\n  Serial.println(\"Configuracion:\");\n  Serial.print(\"  - Servo X en pin GPIO \");\n  Serial.println(PIN_SERVO_X);\n  Serial.print(\"  - Servo Y en pin GPIO \");\n  Serial.println(PIN_SERVO_Y);\n  Serial.print(\"  - Centro: \");\n  Serial.print(CENTRO);\n  Serial.println(\" grados\");\n  Serial.print(\"  - PWM: \");\n  Serial.print(PWM_MIN);\n  Serial.print(\"-\");\n  Serial.print(PWM_MAX);\n  Serial.println(\" us\");\n  Serial.println(\"========================================\");\n  Serial.println(\"Sistema listo. Esperando datos...\");\n  Serial.println(\"Formato: X,Y (ejemplo: 90,85)\");\n  Serial.println(\"========================================\");\n\n  ultimoComando = millis();\n}\n\n// =============== BUCLE PRINCIPAL ===============\nvoid loop() {\n  // Leer datos seriales disponibles\n  while (Serial.available()) {\n    char inChar = (char)Serial.read();\n\n    // Si es salto de l\u00ednea, el comando est\u00e1 completo\n    if (inChar == '\\n' || inChar == '\\r') {\n      if (inputString.length() &gt; 0) {\n        stringComplete = true;\n      }\n    } else {\n      // Agregar caracter al buffer\n      inputString += inChar;\n    }\n  }\n\n  // Procesar comando si est\u00e1 completo\n  if (stringComplete) {\n    procesarComando();\n    inputString = \"\";\n    stringComplete = false;\n    ultimoComando = millis();\n  }\n\n  // Timeout: volver al centro si no hay comandos recientes\n  if (millis() - ultimoComando &gt; TIMEOUT) {\n    volverAlCentro();\n    ultimoComando = millis();\n  }\n}\n\n// =============== FUNCI\u00d3N: PROCESAR COMANDO ===============\nvoid procesarComando() {\n  // Buscar la coma separadora\n  int comaIndex = inputString.indexOf(',');\n\n  if (comaIndex &gt; 0) {\n    // Extraer valores X e Y\n    String valorXStr = inputString.substring(0, comaIndex);\n    String valorYStr = inputString.substring(comaIndex + 1);\n\n    // Convertir a enteros\n    int xRecibido = valorXStr.toInt();\n    int yRecibido = valorYStr.toInt();\n\n    // Validar y limitar al rango 0-180\n    xRecibido = constrain(xRecibido, 0, 180);\n    yRecibido = constrain(yRecibido, 0, 180);\n\n    // Actualizar posiciones\n    posicionX = xRecibido;\n    posicionY = yRecibido;\n\n    // Mover servos\n    servoX.write(posicionX);\n    servoY.write(posicionY);\n\n    // Enviar confirmaci\u00f3n a Python\n    Serial.print(\"Recibido: \");\n    Serial.print(posicionX);\n    Serial.print(\",\");\n    Serial.println(posicionY);\n\n  } else {\n    // Comando inv\u00e1lido (sin coma)\n    Serial.print(\"Error: Formato invalido '\");\n    Serial.print(inputString);\n    Serial.println(\"'. Use: X,Y\");\n  }\n}\n\n// =============== FUNCI\u00d3N: VOLVER AL CENTRO ===============\nvoid volverAlCentro() {\n  static bool mensajeMostrado = false;\n\n  // Movimiento suave hacia el centro\n  if (posicionX != CENTRO || posicionY != CENTRO) {\n    if (!mensajeMostrado) {\n      Serial.println(\"Timeout: Volviendo al centro...\");\n      mensajeMostrado = true;\n    }\n\n    // Acercar gradualmente al centro\n    if (posicionX &lt; CENTRO) posicionX++;\n    if (posicionX &gt; CENTRO) posicionX--;\n    if (posicionY &lt; CENTRO) posicionY++;\n    if (posicionY &gt; CENTRO) posicionY--;\n\n    // Mover servos\n    servoX.write(posicionX);\n    servoY.write(posicionY);\n\n    delay(20);  // Movimiento suave\n  } else {\n    mensajeMostrado = false;\n  }\n}\n</code></pre>"},{"location":"Robot%20Balancin/#instalacion-y-uso","title":"Instalaci\u00f3n y Uso","text":"<ol> <li>Cargar el c\u00f3digo en el ESP32.</li> <li>Ejecutar el script de Python.</li> <li>Verificar que la c\u00e1mara detecte la plataforma.</li> <li>Ajustar par\u00e1metros PID con los sliders.</li> <li>Colocar la pelota sobre la plataforma.</li> <li>Observar la estabilizaci\u00f3n en tiempo real.</li> </ol>"},{"location":"Robot%20Balancin/#conclusiones","title":"Conclusiones","text":"<ul> <li>El robot utiliza visi\u00f3n artificial para estimar posici\u00f3n.</li> <li>El PID corrige la inclinaci\u00f3n con alta precisi\u00f3n.</li> <li>La estructura mec\u00e1nica y servos de alto torque permiten estabilidad.</li> <li>Se obtuvo un robot funcional capaz de mantener el equilibrio de una pelota.</li> </ul>"},{"location":"Robot%20Balancin/#licencia","title":"Licencia","text":"<p>Proyecto acad\u00e9mico desarrollado para fines educativos.</p>"},{"location":"ejemplo/","title":"Control de LED y Actuadores con ESP32","text":""},{"location":"ejemplo/#1-resumen","title":"1) Resumen","text":"<ul> <li>Nombre del proyecto: Control de LED y Actuadores con ESP32  </li> <li>Autor: Eduardo Salamanca  </li> <li>Curso / Asignatura:  Introducci\u00f3n a ala mecatr\u00f3nica</li> <li>Descripci\u00f3n breve:   Este proyecto combina dos pr\u00e1cticas de control b\u00e1sico con el microcontrolador ESP32:  </li> <li>Encendido de un LED mediante Bluetooth.  </li> <li>Manejo de actuadores (motor DC y servomotor) con variaci\u00f3n de giro, velocidad y \u00e1ngulo.   Ambas actividades introducen conceptos esenciales de control digital, PWM y comunicaci\u00f3n inal\u00e1mbrica.</li> </ul>"},{"location":"ejemplo/#2-objetivos","title":"2) Objetivos","text":"<ul> <li> <p>General:   Implementar el control de perif\u00e9ricos y actuadores utilizando el ESP32, aplicando principios de electr\u00f3nica digital, PWM y comunicaci\u00f3n Bluetooth.</p> </li> <li> <p>Espec\u00edficos:</p> </li> <li>Configurar el entorno de desarrollo y los pines de salida del ESP32.  </li> <li>Controlar un LED desde una aplicaci\u00f3n m\u00f3vil por Bluetooth.  </li> <li>Manejar un motor DC con control de giro y velocidad usando PWM.  </li> <li>Controlar un servomotor en distintos \u00e1ngulos mediante se\u00f1ales PWM.  </li> <li>Comprender la relaci\u00f3n entre hardware, programaci\u00f3n y respuesta f\u00edsica del sistema.</li> </ul>"},{"location":"ejemplo/#3-alcance-y-exclusiones","title":"3) Alcance y Exclusiones","text":"<ul> <li>Incluye:</li> <li>Control de LED por Bluetooth.  </li> <li>Control de giro y velocidad de motor DC.  </li> <li>Control de posici\u00f3n de servomotor (0\u00b0 a 180\u00b0).  </li> <li> <p>Programaci\u00f3n completa en Arduino IDE.</p> </li> <li> <p>No incluye:</p> </li> <li>Control autom\u00e1tico por sensores.  </li> <li>Control simult\u00e1neo de m\u00faltiples motores.  </li> <li>Comunicaci\u00f3n Wi-Fi o interfaces gr\u00e1ficas avanzadas.</li> </ul>"},{"location":"ejemplo/#4-requisitos","title":"4) Requisitos","text":""},{"location":"ejemplo/#software","title":"Software","text":"<ul> <li>Sistema operativo: Windows / macOS / Linux  </li> <li>IDE: Arduino IDE 2.x  </li> <li>Bibliotecas necesarias: </li> <li><code>BluetoothSerial.h</code> (control BT)  </li> <li><code>Servo.h</code> (control del servomotor)  </li> </ul>"},{"location":"ejemplo/#hardware","title":"Hardware","text":"<ul> <li>ESP32 DevKit  </li> <li>LED + resistencia de 220 \u03a9  </li> <li>Motor DC     </li> <li>Servomotor   </li> <li>Fuente de alimentaci\u00f3n externa  </li> <li>Protoboard y cables Dupont  </li> </ul>"},{"location":"ejemplo/#conocimientos-previos","title":"Conocimientos previos","text":"<ul> <li>Se\u00f1ales PWM y control de velocidad.  </li> <li>Manejo de pines digitales de salida.  </li> <li>Programaci\u00f3n estructurada en Arduino.  </li> <li>Conexi\u00f3n de componentes electr\u00f3nicos.</li> </ul>"},{"location":"ejemplo/#5-instalacion-y-configuracion","title":"5) Instalaci\u00f3n y Configuraci\u00f3n","text":"<p>Enlace directo</p>"},{"location":"ejemplo/#a-control-de-led-por-bluetooth","title":"A) Control de LED por Bluetooth","text":"<pre><code>#include \"BluetoothSerial.h\"\nBluetoothSerial SerialBT;\n\nint ledPin = 2;\n\nvoid setup() {\n  Serial.begin(115200);\n  SerialBT.begin(\"ESP32_LED\");\n  pinMode(ledPin, OUTPUT);\n}\n\nvoid loop() {\n  if (SerialBT.available()) {\n    char data = SerialBT.read();\n    if (data == '1') digitalWrite(ledPin, HIGH);\n    if (data == '0') digitalWrite(ledPin, LOW);\n  }\n}\n</code></pre> <p>Comandos desde la app Bluetooth: - <code>'1'</code> \u2192 Enciende el LED - <code>'0'</code> \u2192 Apaga el LED  </p>"},{"location":"ejemplo/#b-control-de-motor-dc-giro-y-velocidad","title":"B) Control de motor DC (giro y velocidad)","text":"<p>Enlace directo <pre><code>int ENA = 5;   // PWM (velocidad)\nint IN1 = 18;  // Direcci\u00f3n\nint IN2 = 19;  // Direcci\u00f3n\n\nvoid setup() {\n  pinMode(ENA, OUTPUT);\n  pinMode(IN1, OUTPUT);\n  pinMode(IN2, OUTPUT);\n}\n\nvoid loop() {\n  // Giro en un sentido\n  digitalWrite(IN1, HIGH);\n  digitalWrite(IN2, LOW);\n  analogWrite(ENA, 150); // Velocidad media\n  delay(2000);\n\n  // Aumentar velocidad\n  analogWrite(ENA, 255);\n  delay(2000);\n\n  // Cambiar sentido\n  digitalWrite(IN1, LOW);\n  digitalWrite(IN2, HIGH);\n  analogWrite(ENA, 200);\n  delay(2000);\n\n  // Detener\n  analogWrite(ENA, 0);\n  delay(2000);\n}\n</code></pre></p>"},{"location":"ejemplo/#c-control-de-servomotor","title":"C) Control de servomotor","text":"<pre><code>#include &lt;Servo.h&gt;\nServo servoMotor;\n\nvoid setup() {\n  servoMotor.attach(13); // Pin PWM\n}\n\nvoid loop() {\n  // Mover el servo entre varios \u00e1ngulos\n  servoMotor.write(0);\n  delay(1000);\n  servoMotor.write(90);\n  delay(1000);\n  servoMotor.write(180);\n  delay(1000);\n}\n</code></pre>"},{"location":"ejemplo/#6-resultados-esperados","title":"6) Resultados esperados","text":"<ul> <li>El LED responde correctamente a los comandos Bluetooth.  </li> <li>El motor DC cambia de direcci\u00f3n y velocidad de manera controlada.  </li> <li>El servomotor se posiciona con precisi\u00f3n en los \u00e1ngulos definidos.  </li> <li>Se comprende el uso del PWM en el control de velocidad y posici\u00f3n.</li> </ul>"},{"location":"ejemplo/#7-conclusiones","title":"7) Conclusiones","text":"<ul> <li>Se comprob\u00f3 la versatilidad del ESP32 para controlar diferentes actuadores.  </li> <li>El uso de PWM permiti\u00f3 regular tanto la velocidad de motores como el \u00e1ngulo de servos.  </li> <li>Se integraron conceptos de programaci\u00f3n, electr\u00f3nica y comunicaci\u00f3n inal\u00e1mbrica.  </li> <li>Este proyecto sienta la base para aplicaciones IoT m\u00e1s complejas con sensores y automatizaci\u00f3n.</li> </ul> <p>Enlace directo</p> <p>Enlace directo</p> <p>Enlace directo</p>"},{"location":"ejemplo/#proyecto-2-coche-omnidireccional-controlado-por-bluetooth-esp32-xbox-controller","title":"Proyecto 2 \u2013 Coche Omnidireccional Controlado por Bluetooth (ESP32 + Xbox Controller)","text":"<p>Proyecto acad\u00e9mico de control de movimiento y actuadores, integrando el ESP32 con comunicaci\u00f3n Bluetooth y llantas omnidireccionales. Enlace directo</p>"},{"location":"ejemplo/#1-resumen_1","title":"1\ufe0f Resumen","text":"<ul> <li>Nombre del proyecto: Coche de Futbol Bluetooth con ESP32  </li> <li>Equipo / Autor(es): Eduardo Salamanca y equipo  </li> <li>Curso / Asignatura: Electr\u00f3nica y Programaci\u00f3n de Microcontroladores  </li> <li>Fecha: 20/10/2025  </li> <li>Descripci\u00f3n breve:   Este proyecto implementa un coche omnidireccional controlado mediante Bluetooth, usando un control de Xbox y un ESP32.   El objetivo final fue participar en partidos tipo f\u00fatbol con los coches controlados remotamente.</li> </ul>"},{"location":"ejemplo/#2-objetivos_1","title":"2\ufe0f Objetivos","text":"<ul> <li> <p>General:   Dise\u00f1ar e implementar un sistema m\u00f3vil controlado por Bluetooth que permita controlar la direcci\u00f3n, velocidad y rotaci\u00f3n mediante un control inal\u00e1mbrico.</p> </li> <li> <p>Espec\u00edficos: </p> </li> <li>Implementar el control de movimiento con llantas omnidireccionales.  </li> <li>Integrar puentes H para controlar los motores.  </li> <li>Programar el ESP32 para recibir se\u00f1ales Bluetooth del control.  </li> <li>Dise\u00f1ar la carcasa del coche en MDF mediante corte l\u00e1ser.  </li> <li>Incorporar el control de servomotores y LED del proyecto anterior.  </li> </ul>"},{"location":"ejemplo/#3-alcance-y-exclusiones_1","title":"3\ufe0f Alcance y Exclusiones","text":"<ul> <li>Incluye: </li> <li>Control inal\u00e1mbrico con Bluetooth.  </li> <li>Control direccional completo (adelante, atr\u00e1s, izquierda, derecha, giro).  </li> <li>Control de velocidad variable.  </li> <li>Estructura mec\u00e1nica cortada en MDF.  </li> <li> <p>Integraci\u00f3n de LEDs y servomotores del proyecto anterior.  </p> </li> <li> <p>No incluye: </p> </li> <li>Control por Wi-Fi o conexi\u00f3n a Internet.  </li> <li>Sensores de distancia o evitaci\u00f3n de obst\u00e1culos (versi\u00f3n futura).  </li> </ul>"},{"location":"ejemplo/#4-requisitos_1","title":"4\ufe0f Requisitos","text":""},{"location":"ejemplo/#software_1","title":"Software","text":"<ul> <li>IDE: Arduino IDE (versi\u00f3n m\u00e1s reciente)  </li> <li>Plataforma: ESP32 Dev Module  </li> <li>Librer\u00edas necesarias: </li> <li><code>BluetoothSerial.h</code> </li> <li><code>Servo.h</code> </li> </ul>"},{"location":"ejemplo/#hardware_1","title":"Hardware","text":"<ul> <li>ESP32  </li> <li>4 llantas omnidireccionales  </li> <li>2 puentes H L298N  </li> <li>Servomotor SG90 (para direcci\u00f3n o accesorio)  </li> <li>Jumpers y cables Dupont  </li> <li>Fuente de alimentaci\u00f3n 12 V  </li> <li>Carcasa de MDF cortada con l\u00e1ser  </li> <li>Control Xbox (Bluetooth)  </li> <li>Protoboard  </li> </ul>"},{"location":"ejemplo/#5-codigo-principal-esp32","title":"5\ufe0f C\u00f3digo Principal (ESP32)","text":"<p>```cpp</p>"},{"location":"ejemplo/#include-bluetoothserialh","title":"include \"BluetoothSerial.h\"","text":""},{"location":"ejemplo/#include","title":"include  <p>BluetoothSerial SerialBT;</p>","text":""},{"location":"ejemplo/#define-ena-25","title":"define ENA 25","text":""},{"location":"ejemplo/#define-in1-26","title":"define IN1 26","text":""},{"location":"ejemplo/#define-in2-27","title":"define IN2 27","text":""},{"location":"ejemplo/#define-in3-14","title":"define IN3 14","text":""},{"location":"ejemplo/#define-in4-12","title":"define IN4 12","text":""},{"location":"ejemplo/#define-enb-13","title":"define ENB 13 <p>Servo servo;</p> <p>char comando;</p> <p>void setup() {   Serial.begin(115200);   SerialBT.begin(\"Coche_BT_ESP32\");   servo.attach(15);</p> <p>pinMode(ENA, OUTPUT);   pinMode(ENB, OUTPUT);   pinMode(IN1, OUTPUT);   pinMode(IN2, OUTPUT);   pinMode(IN3, OUTPUT);   pinMode(IN4, OUTPUT);</p> <p>Serial.println(\"Esperando conexi\u00f3n Bluetooth...\"); }</p> <p>void loop() {   if (SerialBT.available()) {     comando = SerialBT.read();     Serial.print(\"Comando recibido: \");     Serial.println(comando);</p> <pre><code>switch (comando) {\n  case 'F':  // Adelante\n    digitalWrite(IN1, HIGH);\n    digitalWrite(IN2, LOW);\n    digitalWrite(IN3, HIGH);\n    digitalWrite(IN4, LOW);\n    analogWrite(ENA, 255);\n    analogWrite(ENB, 255);\n    break;\n\n  case 'B':  // Atr\u00e1s\n    digitalWrite(IN1, LOW);\n    digitalWrite(IN2, HIGH);\n    digitalWrite(IN3, LOW);\n    digitalWrite(IN4, HIGH);\n    analogWrite(ENA, 255);\n    analogWrite(ENB, 255);\n    break;\n\n  case 'L':  // Izquierda\n    digitalWrite(IN1, LOW);\n    digitalWrite(IN2, HIGH);\n    digitalWrite(IN3, HIGH);\n    digitalWrite(IN4, LOW);\n    break;\n\n  case 'R':  // Derecha\n    digitalWrite(IN1, HIGH);\n    digitalWrite(IN2, LOW);\n    digitalWrite(IN3, LOW);\n    digitalWrite(IN4, HIGH);\n    break;\n\n  case 'S':  // Stop\n    digitalWrite(IN1, LOW);\n    digitalWrite(IN2, LOW);\n    digitalWrite(IN3, LOW);\n    digitalWrite(IN4, LOW);\n    break;\n\n  case 'V':  // Servo: variaci\u00f3n de \u00e1ngulo\n    for (int i = 0; i &lt;= 180; i += 10) {\n      servo.write(i);\n      delay(50);\n    }\n    for (int i = 180; i &gt;= 0; i -= 10) {\n      servo.write(i);\n      delay(50);\n    }\n    break;\n}\n</code></pre> <p>} }</p>","text":""}]}